<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #editor {
            width: 100%;
            height: 300px;
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 20px;
            font-family: monospace;
        }
        #log {
            width: 100%;
            height: 200px;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-y: auto;
            font-family: monospace;
            background-color: #f5f5f5;
        }
        .user-cursor {
            position: absolute;
            width: 2px;
            height: 20px;
            background-color: red;
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            padding: 5px 10px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <h1>WebSocket Test</h1>
    
    <div class="controls">
        <input type="text" id="token" placeholder="JWT Token" style="width: 300px;">
        <input type="number" id="documentId" placeholder="Document ID">
        <button onclick="connect()">Connect</button>
        <button onclick="disconnect()">Disconnect</button>
    </div>

    <div id="editor" contenteditable="true"></div>
    
    <div id="log"></div>

    <script>
        let ws = null;
        let documentId = null;
        let cursors = {};

        function log(message) {
            const logDiv = document.getElementById('log');
            logDiv.innerHTML += message + '<br>';
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function connect() {
            const token = document.getElementById('token').value;
            documentId = document.getElementById('documentId').value;
            
            if (!token || !documentId) {
                log('Please provide both token and document ID');
                return;
            }

            ws = new WebSocket(`ws://localhost:8000/api/v1/ws/documents/${documentId}?token=${token}`);

            ws.onopen = () => {
                log('Connected to WebSocket');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                log(`Received: ${JSON.stringify(data)}`);

                switch (data.type) {
                    case 'init':
                        handleInit(data);
                        break;
                    case 'edit':
                        handleEdit(data);
                        break;
                    case 'cursor':
                        handleCursor(data);
                        break;
                    case 'user_joined':
                        handleUserJoined(data);
                        break;
                    case 'user_left':
                        handleUserLeft(data);
                        break;
                }
            };

            ws.onclose = () => {
                log('Disconnected from WebSocket');
                ws = null;
            };

            ws.onerror = (error) => {
                log(`WebSocket error: ${error}`);
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
            }
        }

        function handleInit(data) {
            const editor = document.getElementById('editor');
            editor.innerHTML = data.content;
            
            // Initialize cursors
            cursors = data.cursors;
            updateCursors();
        }

        function handleEdit(data) {
            const editor = document.getElementById('editor');
            const char = data.char;
            
            if (data.operation === 'insert') {
                // Find position to insert
                const position = findPosition(editor, char.position);
                if (position) {
                    const textNode = document.createTextNode(char.value);
                    position.parentNode.insertBefore(textNode, position);
                }
            } else if (data.operation === 'delete') {
                // Find and mark character as deleted
                const position = findPosition(editor, char.position);
                if (position) {
                    position.style.textDecoration = 'line-through';
                    position.style.color = '#999';
                }
            }
        }

        function handleCursor(data) {
            cursors[data.user_id] = data.position;
            updateCursors();
        }

        function handleUserJoined(data) {
            log(`User ${data.user_id} joined`);
        }

        function handleUserLeft(data) {
            log(`User ${data.user_id} left`);
            delete cursors[data.user_id];
            updateCursors();
        }

        function findPosition(editor, position) {
            // This is a simplified version - in a real implementation,
            // you would need to map CRDT positions to DOM positions
            return editor.firstChild;
        }

        function updateCursors() {
            // Remove existing cursors
            document.querySelectorAll('.user-cursor').forEach(cursor => cursor.remove());
            
            // Add new cursors
            Object.entries(cursors).forEach(([userId, position]) => {
                const cursor = document.createElement('div');
                cursor.className = 'user-cursor';
                cursor.style.left = `${position}px`;
                cursor.style.backgroundColor = getColorForUser(userId);
                document.getElementById('editor').appendChild(cursor);
            });
        }

        function getColorForUser(userId) {
            // Generate a consistent color for each user
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#00ffff'];
            return colors[parseInt(userId) % colors.length];
        }

        // Handle editor changes
        document.getElementById('editor').addEventListener('input', (event) => {
            if (!ws) return;

            const selection = window.getSelection();
            const range = selection.getRangeAt(0);
            const index = range.startOffset;

            // Send edit operation
            ws.send(JSON.stringify({
                type: 'edit',
                operation: 'insert',
                index: index,
                value: event.data
            }));
        });

        // Handle cursor movement
        document.getElementById('editor').addEventListener('keyup', (event) => {
            if (!ws) return;

            const selection = window.getSelection();
            const range = selection.getRangeAt(0);
            const position = range.startOffset;

            // Send cursor position
            ws.send(JSON.stringify({
                type: 'cursor',
                position: position
            }));
        });
    </script>
</body>
</html> 